# Mongo DB

Будем работать с датасетом GitHub Events: 
 
https://www.gharchive.org

Смысловой центр почти всех заданий - в формировании запросов. Но они делаются через клиента. И поскольку у нет
ярко выраженного текстового языка запросов, клиентская часть играет некоторую роль.

В клиентской части вы можете использовать любой из языков, разрешенных во второй домашке. Но было бы странно запрещать
работать через `mongosh`, поэтому в список поддержки здесь добавляется JS.

Ожидается, что клиент используется типовой для данного языка - не хотелось бы в ходе проверки работ погружаться в детали
какой-то специфичной авторской разработки.

Идеальный вариант - официальный клиент от MongoDb для данного языка. Если такого нет - самый популярный в сообществе.

Не надо очень продвинутых декларативных построителей запросов. Пусть все будет в абстракциях `MongoDb`.

Не надо сложных фреймворков и архитектурных излишеств.

Если сами своими руками рутинную подготовку уберете в свои функции - это OK.

Выложите нужные артефакты для сборки и сделайте ее максимально самодостаточной.

Но не выкладывайте лишнего - IDE-проектов, сгенерированных бинарников и т.п.

Как проверить, что есть все нужное и нет ничего лишнего:

- склонируйте репозиторий в новое место и проверьте, что в нем все работает
- зайдите в Pull Request и убедитесь, что там нет ничего лишнего

Напишите простой HOWTO.md с описанием запуска вашего кода.

Если сделаете `Dockerfile` для сборки - OK. Но не стоит заливать туда саму MongoDB.


## Задание 1

5 баллов

Организуем начальную загрузку данных.

Клиентский код - приложение, принимающее следующие параметры командной строки:

- ссылка на mongodb-сервер
- имя базы
- имя коллекции
- дипазон дан в формате `2015-11-05:2016-02-03`

Приложение должно взять данные из указанного диапазона и загрузить в указанную таблицу, предполагая,
что такой таблицы нет.

Данные должны быть загружены как есть.

Загрузка должна работать максимально эффективно по скорости.

## Задание 2

5 баллов

Организуем дополнительную подгрузку данных.

Клиентский код - приложение, принимающее те же параметры командной строки, что и в задании 1.

Надо ориентироваться на идентификатор события (поле `id` в корне документа).

Те документы из диапазона, которые есть в данной коллекции данной базы (в смысле "есть документ с тем же id"), не должны
добавляться, а те, которых нет - должны.

Логика определения, что добавлять, а что не добавлять должна в максимально возможной степени работать на стороне сервера.

Если в прошлом задании данные должны были загружаться как есть, то здесь в интересах эффективности можно немного пошевелить
данные. Несильно, на уровне переименования каких-то полей.

## Задание 3

15 баллов

Во всех событиях указывается актор и навскидку для него всегда указывается `login` и `id`.

Выясним
-  всегда ли для события указывается `actor.id`
-  всегда ли для события указывается `actor.login`
-  нет ли таких случаев, когда для одного и того же `actor.login` в разных событиях указываются разные `actor.id`
-  нет ли таких случаев, когда для одного и того же `actor.id` в разных событиях указываются разные `actor.login`

Хотим получить документ с полями:
- n_no_id: количество документов без `actor.id`
- n_no_login: количество документов без `actor.login`
- n_one_login_many_id - количество `actor.id`, которым соответствует более одного `actor.login`
- n_one_id_many_login - количество `actor.login`, которым соответствует более одного `actor.id`


## Задание 3

15 баллов

Сформируем коллекцию, в которой каждому GitHub-пользователю будет соответствовать документ с полями:

- user_id: id GitHub-пользователя
- events: список документов, в каждом из которых хранятся имена событий и количество таких событий, которые совершил
  данный пользователь
- events_by_ym: список документов, в каждом из которых хранится гистограмма событий данного пользователя по паре год-месяц,
  То есть в каждом документе есть поле с годом, поле с месяцем (число в диапазоне 1-12), и поле events - по структуре как в предыдущем пункте, только с данными по отдельному месяцу. И этот список должен быть упорядочен по времени (более ранние месяцы в начале)
- pushed_to: список имен репозиториев, по которые делал push данный пользователь

  В  гистограммах событий должны отсутствовать типы событий, которые в данные период не встречались.
  
## Задание 4

15 баллов

Найдем top-k репозиториев по количеству открытых в них issue в рамках тех данных, что нам доступны.

Сгруппируем их по организации (часть в имени до '/')

Сформируем коллекцию документов с такими полями

- org_name: имя организации
- repos: список документов, хранящих знание о именах репозиториев данной организации, попавших в top-k
 и о количестве пользователей, делавших `push` в данный репозиторий не менее трех раз

Параметр k должен задаваться на клиентской стороне максимально удобным способом - насколько это позволяет
клиентская библиотека.


## Задание 5

15 баллов

Во всех событиях указывается актор и навскидку для него всегда указывается `login` и `id`.

Выясним
-  всегда ли для события указывается `actor.id`
-  всегда ли для события указывается `actor.login`
-  нет ли таких случаев, когда для одного и того же `actor.login` в разных событиях указываются разные `actor.id`
-  нет ли таких случаев, когда для одного и того же `actor.id` в разных событиях указываются разные `actor.login`

Хотим получить документ с полями:
- n_no_id: количество документов без `actor.id`
- n_no_login: количество документов без `actor.login`
- n_one_login_many_id - количество `actor.id`, которым соответствует более одного `actor.login`
- n_one_id_many_login - количество `actor.login`, которым соответствует более одного `actor.id


## Задание 6

15 баллов

Найдем все пары пользователей `a` и `b` таких, что:

- `a` хотя бы раз делал push в репозиторий, созданный `b`

- `b` хотя бы раз делал push в репозиторий, созданный `a`

Породим коллекцию документов и такими парами. Каждый пользователь представлен в документе
своим id и логином.


## Задание 7

20 баллов

Знакомое на новый лад

(забыли про github)

Есть коллекция с документами, в которых есть поля `id`, `n` и `a`.

`n` и `a` - некоторые целочисленные показатели.

Если мысленно упорядочить записи по неубыванию `n`, то можно выделить периоды плавного неубывания. Период плавного неубывания - это участок, на котором `n` не растет или растет на `1`. Иногда период плавного неубывания может иметь длину `1`.

Например, в последовательности `2 2 3 5 5 7 8 9 10 12 20 25 26`  есть следующие периоды плавного неубывания:
`2 2 3`, `5 5`, `7 8 9`, `10, 12`, `20`, `25 26`.

Напишем запрос, который для каждого `id` покажет разницу между его показателем `a` и средним `a` по его и следующему периоду плавного неубывания. То есть для `id`, чей `n` равен `7`, мы возьмем среднее `a` по тем записям, чей `n` равен `7, 8, 9, 10 и 12`.
Если следующего периода нет - берем только по текущему.


## Задание 8

10 баллов

Для каждого доменного имени второго уровня, являющегося именем хоста в почтовом адресе коммита, посчитать количество репозиториев,
в которые приехали коммиты, помеченные данным именем хоста.

Ранжировать их по количеству.

Породить коллекцию документов, хранящих имя хоста и количество репозиториев.

То есть интересны коммиты с адресами типа `john@oracle.com`, а адреса типа `abc@q.w.com` пропускаем (имя хоста не является
доменным именем второго уровня).

Понятно что самым топом будут почтовые хостинги, а вот дальше интересно, в сколько репозиториев едут коммиты, помеченные  корпоративными адресами Оракла или Яндекса (по модулю того, что адреса в коммитах заполняются со слов локального юзера без проверок).
